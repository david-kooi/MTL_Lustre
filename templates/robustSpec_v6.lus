

const TRUE_r  :real = 9999.0;
const FALSE_r :real = -9999.0;



--type State_idx = enum {theta, d_theta, set_point};
const theta:int = 0; 
const d_theta:int = 1;
const set_point:int = 2;

const n: int = 3; -- State Size
const AP_size: int = 2; 
const Phi_size: int = 3;

type SamplePoint         = {t : real; s : real^n};
type PerformancePoint    = real^Phi_size;
type PerformancePoint_AP = real^AP_size;

-- There is a new set point
node f_AP_0(SP : SamplePoint) returns(mu: real);
let 
    mu = Abs(SP.s[set_point] - Previous(SP.s[set_point]))-0.1; 
tel

-- The error is within 10% of the setpoint
node f_AP_1(SP : SamplePoint) returns(mu: real);
let
    mu = 0.1 - (Abs(SP.s[theta] - SP.s[set_point]) / SP.s[set_point]); 
tel

node ComputeRho_AP(SP : SamplePoint) returns(Rho_AP:PerformancePoint_AP); 
let
    Rho_AP[0] = f_AP_0(SP);
    Rho_AP[1] = f_AP_1(SP);
tel

node ComputeRho_Phi(Rho_AP : PerformancePoint_AP) returns(Rho:PerformancePoint);
let
   --Rho[0..AP_size-1] = Rho_AP; 
    Rho[0] = Rho_AP[0];
    Rho[1] = Rho_AP[1]; 
    Rho[AP_size] = Once_Interval<<0,5>>(Rho[1]);--Implies(Once_Interval<<0,15>>(Rho_AP[0]),
                   --       Once_Interval<<0,15>>(Rho_AP[1]));
tel



node Main(SP: SamplePoint) returns(Rho: PerformancePoint); 
var Rho_AP: PerformancePoint_AP;
let 
    Rho_AP = ComputeRho_AP(SP); 
    Rho    = ComputeRho_Phi(Rho_AP); 
tel



node MainTest(x,y:real) returns(z:real);
let
    --z = Delay<<5>>(x);
    --z = Sliding_Min<<5>>(x);
    --z = Previous(x);
    --z = Since_Interval<<0,5>>(x,y);
    --z = Once_Interval<<0,2>>(x);
    --z = Always_Interval<<0,2>>(x);
    --z = Always_Inf(x);
    --z = Once_Inf(x);
tel


-- Boolean Translation
node BoolToReal(x:bool) returns (z:real);
let
    z = if(x) then TRUE_r else FALSE_r;
tel


-- Quantatative MTL Operators

-- x -> y = not x or y
node Implies(x,y:real) returns(z:real);
let
    z = Or(Not(x), y); 
tel

node Or(x,y:real) returns(z:real);
let
    z = Max_2(x,y);
tel


node And(x,y:real) returns(z:real);
let
    z = Min_2(x,y);
tel


node Not(x:real) returns(not_x:real);
let
    not_x = -x;
tel

-- y S[l,u] x with past interval
node Since_Interval<<const l:int; const u:int>>(x,y:real) returns (z:real);
let
    assert(l>=0);
    assert(u>0);

   z = Since_Recurse<<l,u,0>>(x, y);

tel

-- y S[0,inf] x 
-- From [Dokhanchi, Fainekos 2014]
node Since_Inf(x,y:real) returns(z:real);
var tmp_1, pre_z:real;
let
    pre_z = FALSE_r -> pre z;
    tmp_1 = Min_2(y,pre_z);
    z = Max_2(x,tmp_1);
tel

node Previous(x:real) returns (z:real);
let
    z = Since_Interval<<1,1>>(x,99.0);
    --z = delay<<1>>(x);
tel

node Once_Interval<<const l:int; const u:int>>(x:real) returns(z:real);
let
    z = Since_Interval<<l,u>>(x, TRUE_r);
tel

node Always_Interval<<const l:int; const u:int>>(x:real) returns(z:real);
let
    z = Not( Once_Interval<<l,u>>(Not(x)) );
tel

node Always_Inf(x:real) returns(z:real);
let
    z = Min(x);
tel

node Once_Inf(x:real) returns(z:real);
let
    z = Max(x);
tel




-- Involved Computations --

-- Delay n steps
-- Note: The delay bottoms out at the first value of x
node Delay<<const n:int>>(x:real) returns (z:real);
let

    z = with (n<=0) then  x
                   else x -> pre Delay<<n-1>>(x);
tel


node Since_Recurse<<const l:int; const u:int; const q:int>>(x,y:real) returns(z:real);
var x_n, min_m, min_n:real;
let 
    assert(u-l>=0); 

    x_n = Delay<<l+q>>(x); 
    min_m = Sliding_Min<<l+q-1>>(y); 
    min_n = Min_2(x_n, min_m);
    z = with (q=u-l) then min_n
                     else Max_2(min_n, Since_Recurse<<l,u,q+1>>(x,y));
            
tel

-- Non Inclusive Since
node Since_Recurse_noInc<<const l:int; const u:int; const q:int>>(x,y:real) returns(z:real);
var x_n, min_m, min_n:real;
let 
    assert(u-l>=0); 

    x_n = Delay<<l+q+1>>(x); 
    min_m = Sliding_Min<<l+q>>(y); 
    min_n = Min_2(x_n, min_m);
    z = with (q=u-l-1) then min_n
                     else Max_2(min_n, Since_Recurse<<l,u,q+1>>(x,y));
            
tel



node Sliding_Min<<const n:int>>(x:real) returns (z:real);
var x_n:real;
let   
    x_n = Delay<<n>>(x);
    z = with(n<=0) then x_n
                  else Min_2(x_n,Sliding_Min<<n-1>>(x)); 

tel



-- Simple Computations --
node Abs(x:real) returns(abs_x:real);
let
    abs_x = if(x > 0.0) then x else -x;
tel

-- Max of a stream
node Max(x:real) returns(max:real);
let
    max = x-> if(x > pre max) then x else pre max;
tel

-- Min of a stream
node Min(x:real) returns(min:real);
let
    min = x -> if(x < pre min) then x else pre min;
tel

-- Max between two streams 
node Max_2(x,y: real) returns(max:real);
let
    max = if(x>y) then x else y;
tel

-- Min between two streams
node Min_2(x,y: real) returns(min:real);
let
    min = if(x>y) then y else x;
tel



